---
phase: 05-cli-immediate-update
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/main.go
  - cmd/main_test.go
autonomous: true
requirements:
  - CLI-01
  - CLI-02
  - CLI-03
  - CLI-04
  - CLI-05
user_setup: []

must_haves:
  truths:
    - "User can run with --update-now flag to trigger immediate update"
    - "User can specify --timeout flag to configure update timeout"
    - "JSON output is emitted to stdout as the last line on --update-now"
    - "Exit code is 0 on success, non-zero on failure"
    - "Help output documents the new flags and JSON format"
    - "Old --run-once flag is removed"
  artifacts:
    - path: "cmd/main.go"
      provides: "CLI entry point with --update-now and --timeout flags"
      contains: "--update-now"
    - path: "cmd/main.go"
      provides: "JSON output formatting"
      contains: "encoding/json"
  key_links:
    - from: "cmd/main.go"
      to: "internal/updater/updater.go"
      via: "u.Update(ctx)"
      pattern: "Update\\(ctx"
    - from: "cmd/main.go"
      to: "internal/lifecycle/manager.go"
      via: "lifecycle manager calls"
      pattern: "StopForUpdate|StartAfterUpdate"
---

<objective>
Add --update-now flag for immediate update execution with JSON output for programmatic consumption. Replace existing --run-once flag with enhanced functionality including configurable timeout and structured output.

Purpose: Enable third-party programs to invoke the updater and parse results programmatically
Output: Modified cmd/main.go with new CLI flags, JSON output, and updated help documentation
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/allan716/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cli-immediate-update/05-CONTEXT.md
@.planning/phases/05-cli-immediate-update/05-RESEARCH.md
@cmd/main.go
@internal/updater/updater.go
@internal/lifecycle/manager.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new CLI flags and remove --run-once</name>
  <files>cmd/main.go</files>
  <action>
Modify cmd/main.go to update the CLI flag handling:

1. **Remove the --run-once flag** and replace with new flags:
   - Remove: `runOnce := flag.Bool("run-once", false, ...)`
   - Add: `updateNow := flag.Bool("update-now", false, "Execute immediate update and exit with JSON output")`
   - Add: `timeout := flag.Duration("timeout", 5*time.Minute, "Update timeout duration (e.g., '5m', '300s')")`

2. **Update the help documentation** at the --help handler section:
   - Add documentation for --update-now flag
   - Add documentation for --timeout flag
   - Add JSON output format documentation for third-party consumers:
     ```
     JSON Output Format (--update-now):
       Success: {"success": true, "version": "X.Y.Z", "source": "github|pypi", "message": "Update completed"}
       Failure: {"success": false, "error": "description", "exit_code": 1}
     ```

3. **Update the log line** that currently references runOnce:
   - Change: `"run_once", *runOnce` to: `"update_now", *updateNow, "timeout", timeout.String()`

4. **Do NOT modify** the update logic in this task - just the flag definitions and help text.
  </action>
  <verify>go build ./cmd/main.go compiles without errors</verify>
  <done>CLI has --update-now and --timeout flags, --run-once is removed, help documents JSON format</done>
</task>

<task type="auto">
  <name>Task 2: Implement --update-now handler with lifecycle and JSON output</name>
  <files>cmd/main.go</files>
  <action>
Modify cmd/main.go to implement the --update-now execution flow:

1. **Add import for encoding/json** at the top of the file

2. **Define JSON result struct** before main():
   ```go
   // UpdateNowResult represents the JSON output for --update-now mode
   type UpdateNowResult struct {
       Success  bool   `json:"success"`
       Version  string `json:"version,omitempty"`
       Source   string `json:"source,omitempty"`
       Message  string `json:"message,omitempty"`
       Error    string `json:"error,omitempty"`
       ExitCode int    `json:"exit_code,omitempty"`
   }
   ```

3. **Replace the existing `if *runOnce` block** (around line 89-98) with the new --update-now handler:
   ```go
   if *updateNow {
       logger.Info("Executing immediate update", "timeout", timeout.String())

       // Create context with configurable timeout
       ctx, cancel := context.WithTimeout(context.Background(), *timeout)
       defer cancel()

       // Initialize lifecycle manager
       lifecycleCfg := lifecycle.Config{
           Port:           cfg.Nanobot.Port,
           StartupTimeout: cfg.Nanobot.StartupTimeout,
       }
       lifecycleMgr := lifecycle.NewManager(lifecycleCfg)

       result := UpdateNowResult{}

       // Stop nanobot before update
       if err := lifecycleMgr.StopForUpdate(ctx); err != nil {
           logger.Error("Failed to stop nanobot", "error", err.Error())
           result = UpdateNowResult{
               Success:  false,
               Error:    fmt.Sprintf("Failed to stop nanobot: %s", err.Error()),
               ExitCode: 1,
           }
           outputJSON(result)
           os.Exit(1)
       }

       // Execute update
       u := updater.NewUpdater(logger)
       updateResult, err := u.Update(ctx)
       if err != nil {
           logger.Error("Update failed", "result", updateResult, "error", err.Error())
           result = UpdateNowResult{
               Success:  false,
               Error:    err.Error(),
               ExitCode: 1,
           }
           outputJSON(result)
           os.Exit(1)
       }

       // Start nanobot after successful update
       if err := lifecycleMgr.StartAfterUpdate(ctx); err != nil {
           // Log warning but don't fail - update was successful
           logger.Warn("Failed to start nanobot after update", "error", err.Error())
       }

       result = UpdateNowResult{
           Success: true,
           Source:  string(updateResult),
           Message: "Update completed",
       }
       logger.Info("Update completed", "result", updateResult)
       outputJSON(result)
       os.Exit(0)
   }
   ```

4. **Add the outputJSON helper function** before main():
   ```go
   // outputJSON writes the result as JSON to stdout (last line)
   func outputJSON(result UpdateNowResult) {
       output, err := json.Marshal(result)
       if err != nil {
           fmt.Fprintf(os.Stderr, "Failed to encode JSON: %v\n", err)
           return
       }
       fmt.Println(string(output))
   }
   ```

5. **Add lifecycle import** if not present: `"github.com/HQGroup/nanobot-auto-updater/internal/lifecycle"`

Key behaviors to implement:
- Context with timeout from --timeout flag
- Lifecycle manager with config values
- StopForUpdate -> Update -> StartAfterUpdate flow
- JSON output as the LAST LINE of stdout
- Exit code 0 on success, 1 on failure
- StartAfterUpdate failure logs warning only (does not fail the update)
  </action>
  <verify>
go build ./cmd/main.go compiles without errors
go run ./cmd/main.go --help shows --update-now and --timeout flags
  </verify>
  <done>--update-now executes full lifecycle flow and outputs JSON to stdout</done>
</task>

<task type="auto">
  <name>Task 3: Update tests for new CLI flags</name>
  <files>cmd/main_test.go</files>
  <action>
Update cmd/main_test.go to reflect the new CLI flags:

1. **Update any existing tests** that reference --run-once:
   - Change references from `--run-once` to `--update-now`
   - Update test descriptions accordingly

2. **Add new test cases** for --update-now and --timeout flags:
   - Test that --update-now flag is recognized
   - Test that --timeout flag is parsed correctly (e.g., "5m" -> 5 minutes)
   - Test help output includes new flags and JSON format documentation

3. **If no tests exist**, add basic flag parsing tests:
   ```go
   func TestUpdateNowFlag(t *testing.T) {
       // Test that --update-now flag exists
   }

   func TestTimeoutFlag(t *testing.T) {
       // Test that --timeout flag parses duration correctly
   }
   ```

Note: Integration tests for the full update flow are manual tests documented in comments in main.go.
  </action>
  <verify>go test ./cmd/... passes</verify>
  <done>Tests updated for new CLI flags, all tests pass</done>
</task>

</tasks>

<verification>
1. Build compiles without errors: `go build ./cmd/main.go`
2. Tests pass: `go test ./cmd/...`
3. Help shows new flags: `go run ./cmd/main.go --help`
4. --update-now executes update flow with JSON output
5. --timeout flag is respected
6. Exit codes are correct (0 success, 1 failure)
</verification>

<success_criteria>
- [ ] --update-now flag triggers immediate update and exits
- [ ] --timeout flag configures update timeout (default 5 minutes)
- [ ] JSON output emitted to stdout as last line
- [ ] Exit code 0 on success, non-zero on failure
- [ ] Help output documents new flags and JSON format
- [ ] --run-once flag removed completely
- [ ] All tests pass
- [ ] Lifecycle flow (stop -> update -> start) works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05-cli-immediate-update/05-01-SUMMARY.md`
</output>
