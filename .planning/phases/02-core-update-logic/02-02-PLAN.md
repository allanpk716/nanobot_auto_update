---
phase: 02-core-update-logic
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - internal/updater/updater.go
  - internal/updater/updater_test.go
  - cmd/main.go
autonomous: true
requirements:
  - UPDT-03
  - UPDT-04
  - UPDT-05
  - INFR-10
user_setup: []

must_haves:
  truths:
    - "User can trigger an update that installs nanobot from GitHub main branch using uv"
    - "If GitHub update fails, program automatically falls back to installing nanobot-ai stable version from PyPI"
    - "All update attempts are logged with detailed success/failure information"
    - "Update result (success/fallback/failure) is visible in logs"
    - "Executed uv commands do not flash a command prompt window"
  artifacts:
    - path: "internal/updater/updater.go"
      provides: "Core update logic with GitHub primary and PyPI fallback"
      exports: ["Updater", "NewUpdater", "Update", "UpdateResult"]
      min_lines: 80
    - path: "internal/updater/updater_test.go"
      provides: "Test coverage for updater"
      contains: "TestUpdate"
  key_links:
    - from: "internal/updater/updater.go"
      to: "uv command"
      via: "exec.CommandContext with hidden window"
      pattern: "SysProcAttr.*HideWindow"
    - from: "cmd/main.go"
      to: "internal/updater.Updater"
      via: "NewUpdater and Update calls"
      pattern: "updater\\.NewUpdater"
---

<objective>
Implement core update logic with GitHub main branch primary update and automatic PyPI fallback.

Purpose: Enable nanobot updates from GitHub with fallback to stable PyPI version if GitHub fails.
Output: internal/updater/updater.go with Updater struct and Update method, integrated with main.go.
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/allan716/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-update-logic/02-RESEARCH.md

# Reference existing patterns
@internal/lifecycle/stopper.go - SysProcAttr with HideWindow and CREATE_NO_WINDOW pattern
@internal/lifecycle/starter.go - Hidden window pattern
@internal/updater/checker.go - Package structure

# Prior plan context
@.planning/phases/02-core-update-logic/02-01-SUMMARY.md - UV checker completed
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Updater struct with hidden command execution</name>
  <files>internal/updater/updater.go</files>
  <action>
Create `internal/updater/updater.go` with core update logic:

1. Build constraint: `//go:build windows`
2. Package: `updater`
3. Define UpdateResult type and constants:
   ```go
   type UpdateResult string
   const (
       ResultSuccess  UpdateResult = "success"   // GitHub update succeeded
       ResultFallback UpdateResult = "fallback"  // PyPI fallback succeeded
       ResultFailed   UpdateResult = "failed"    // Both failed
   )
   ```

4. Define Updater struct with:
   - logger *slog.Logger
   - githubURL string (default: "git+https://github.com/nanobot-ai/nanobot@main")
   - pypiPackage string (default: "nanobot-ai")
   - updateTimeout time.Duration (default: 5 * time.Minute)

5. Implement NewUpdater(logger *slog.Logger) *Updater with defaults

6. Implement runCommand(ctx context.Context, name string, args ...string) (string, error):
   - Uses exec.CommandContext with timeout context
   - Sets SysProcAttr: HideWindow: true, CreationFlags: windows.CREATE_NO_WINDOW
   - Uses bytes.Buffer for combined stdout/stderr
   - Returns output string and error

7. Implement truncateOutput(s string) string:
   - Limits output to 500 characters for logging
   - Appends "... (truncated)" if truncated

CRITICAL: Must use exact SysProcAttr pattern from lifecycle/stopper.go to hide command windows (INFR-10).
</action>
  <verify>
Run: `go build ./internal/updater`
Expected: Compiles without errors
  </verify>
  <done>
- updater.go exists with Updater struct
- runCommand uses hidden window SysProcAttr pattern
- UpdateResult constants defined
- Helper functions implemented
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Update method with GitHub primary and PyPI fallback</name>
  <files>internal/updater/updater.go</files>
  <action>
Add Update method to Updater struct:

```go
func (u *Updater) Update(ctx context.Context) (UpdateResult, error) {
    ctx, cancel := context.WithTimeout(ctx, u.updateTimeout)
    defer cancel()

    // Primary: Try GitHub main branch
    u.logger.Info("Starting update from GitHub main branch")
    output, err := u.runCommand(ctx, "uv", "tool", "install", u.githubURL)
    if err == nil {
        u.logger.Info("Update successful from GitHub",
            "source", "github",
            "output", truncateOutput(output))
        return ResultSuccess, nil
    }

    u.logger.Warn("GitHub update failed, attempting PyPI fallback",
        "error", err.Error(),
        "github_output", truncateOutput(output))

    // Fallback: Try PyPI stable version
    output, err = u.runCommand(ctx, "uv", "tool", "install", u.pypiPackage)
    if err == nil {
        u.logger.Info("Update successful from PyPI fallback",
            "source", "pypi",
            "output", truncateOutput(output))
        return ResultFallback, nil
    }

    u.logger.Error("Update failed - both GitHub and PyPI attempts failed",
        "pypi_output", truncateOutput(output),
        "error", err.Error())
    return ResultFailed, fmt.Errorf("update failed (GitHub and PyPI): %w", err)
}
```

Log at each step (UPDT-05):
- INFO: Starting GitHub update
- INFO: GitHub success with output
- WARN: GitHub failed, trying fallback (with error and output)
- INFO: PyPI success with output
- ERROR: Both failed (with outputs and error)
</action>
  <verify>
Run: `go build ./internal/updater`
Expected: Compiles without errors
  </verify>
  <done>
- Update method implements GitHub primary, PyPI fallback logic
- Correct logging at each step
- Returns appropriate UpdateResult
- Context timeout applied
  </done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for updater</name>
  <files>internal/updater/updater_test.go</files>
  <action>
Create `updater_test.go` with tests:

1. Test `TestNewUpdater`:
   - Create logger with slog.New(slog.NewTextHandler(os.Stdout, nil))
   - Call NewUpdater(logger)
   - Verify defaults are set correctly

2. Test `TestTruncateOutput`:
   - Test short string returns unchanged
   - Test long string gets truncated to 500 chars + "... (truncated)"

3. Test `TestUpdateResultConstants`:
   - Verify constants are defined correctly

Note: Full Update testing requires actual uv command - can be verified manually or in integration tests.
</action>
  <verify>
Run: `go test ./internal/updater -v`
Expected: Tests pass
  </verify>
  <done>
- updater_test.go exists with meaningful tests
- Tests verify NewUpdater defaults
- Tests verify truncateOutput behavior
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate updater with main.go run-once mode</name>
  <files>cmd/main.go</files>
  <action>
Modify `cmd/main.go` to use the updater in run-once mode:

1. Find the `if *runOnce` block (around line 79)
2. Replace the TODO comment and placeholder with:
   ```go
   if *runOnce {
       logger.Info("Executing one-time update")
       u := updater.NewUpdater(logger)
       result, err := u.Update(context.Background())
       if err != nil {
           logger.Error("Update failed", "result", result, "error", err.Error())
           os.Exit(1)
       }
       logger.Info("Update completed", "result", result)
       os.Exit(0)
   }
   ```

3. Add import for context: `"context"`
4. Keep the TODO comments for Phase 3 (scheduling)

This enables immediate testing of the update logic via `go run ./cmd/main.go -run-once`.
</action>
  <verify>
Run: `go build ./cmd`
Expected: Compiles without errors

Manual test: `go run ./cmd/main.go -run-once`
Expected: Executes update with visible logs
  </verify>
  <done>
- main.go uses updater package
- run-once mode triggers Update call
- Exit code 1 on failure, 0 on success
- Result logged appropriately
  </done>
</task>

</tasks>

<verification>
1. Build check: `go build ./...` passes
2. Test check: `go test ./internal/updater -v` passes
3. Run-once check: `go run ./cmd/main.go -run-once` executes update
4. Log verification: Logs show GitHub attempt, fallback (if needed), and result
5. Hidden window check: No console window flashes during uv commands
</verification>

<success_criteria>
- Updater struct with Update method exists
- GitHub primary update works
- PyPI fallback works when GitHub fails
- All update steps logged with detail
- No command window flashing (INFR-10)
- run-once mode triggers update correctly
- Exit codes reflect success/failure
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-update-logic/02-02-SUMMARY.md`
</output>
