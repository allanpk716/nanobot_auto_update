---
phase: 03-scheduling-and-notifications
plan: 03
type: execute
wave: 2
depends_on:
  - 03-01
  - 03-02
files_modified:
  - cmd/main.go
autonomous: true
requirements:
  - SCHD-01
  - SCHD-02
  - SCHD-03
  - NOTF-02
  - NOTF-03

must_haves:
  truths:
    - "Program executes updates automatically based on cron expression from configuration"
    - "Default schedule runs daily at 3 AM (0 3 * * *)"
    - "Overlapping update jobs are skipped if previous job is still running"
    - "User receives Pushover notification when scheduled update fails"
    - "Program handles graceful shutdown on SIGINT/SIGTERM"
  artifacts:
    - path: "cmd/main.go"
      provides: "Main entry point with scheduled mode"
      contains: "scheduler.New"
      min_lines: 140
  key_links:
    - from: "cmd/main.go"
      to: "internal/scheduler"
      via: "import and scheduler.New()"
      pattern: "scheduler\\.New\\(logger\\)"
    - from: "cmd/main.go"
      to: "internal/notifier"
      via: "import and notifier.New()"
      pattern: "notifier\\.New\\(logger\\)"
    - from: "cmd/main.go"
      to: "scheduler.AddJob callback"
      via: "update job function"
      pattern: "sched\\.AddJob.*u\\.Update"
    - from: "cmd/main.go"
      to: "notifier.NotifyFailure"
      via: "on update error"
      pattern: "notif\\.NotifyFailure"
---

<objective>
Wire scheduler and notifier into main.go to replace the TODO: Phase 3 placeholder with full scheduled mode implementation.

Purpose: Complete the scheduled execution feature with automatic update triggering and failure notifications.
Output: Updated cmd/main.go with scheduler and notifier integration
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@.planning/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scheduling-and-notifications/03-RESEARCH.md

# Prior plan context
@.planning/phases/03-scheduling-and-notifications/03-01-PLAN.md - Scheduler package
@.planning/phases/03-scheduling-and-notifications/03-02-PLAN.md - Notifier package

# Current implementation
@cmd/main.go - Entry point with TODO: Phase 3 placeholder (lines 97-98)
@internal/updater/updater.go - Updater struct with Update method
@internal/config/config.go - Config struct with Cron field
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scheduler and notifier imports and integration to main.go</name>
  <files>cmd/main.go</files>
  <action>
Update cmd/main.go to integrate scheduler and notifier:

1. Add imports:
   - "os/signal"
   - "syscall"
   - "github.com/HQGroup/nanobot-auto-updater/internal/scheduler"
   - "github.com/HQGroup/nanobot-auto-updater/internal/notifier"

2. Replace lines 97-98 (the TODO: Phase 3 placeholder) with scheduled mode implementation:

```go
// Initialize notifier (logs warning if Pushover not configured)
notif := notifier.New(logger)

// Initialize scheduler with overlap prevention
sched := scheduler.New(logger)

// Create updater instance
u := updater.NewUpdater(logger)

// Register the update job
err = sched.AddJob(cfg.Cron, func() {
    logger.Info("Starting scheduled update job")

    result, err := u.Update(context.Background())
    if err != nil {
        logger.Error("Scheduled update failed",
            "result", result,
            "error", err.Error())

        // Send failure notification
        if notifyErr := notif.NotifyFailure("Scheduled Update", err); notifyErr != nil {
            logger.Error("Failed to send failure notification", "error", notifyErr.Error())
        }
        return
    }

    logger.Info("Scheduled update completed successfully", "result", result)
})
if err != nil {
    logger.Error("Failed to register scheduled job", "error", err.Error())
    os.Exit(1)
}

// Set up signal handling for graceful shutdown
sigChan := make(chan os.Signal, 1)
signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

// Start the scheduler
sched.Start()
logger.Info("Scheduler started", "cron", cfg.Cron, "pid", os.Getpid())

// Wait for shutdown signal
sig := <-sigChan
logger.Info("Shutdown signal received", "signal", sig.String())

// Gracefully stop scheduler
sched.Stop()
logger.Info("Application shutdown complete")
```

3. CRITICAL: Maintain exact error handling pattern - logger.Error uses err.Error() not err directly

4. The notifier is initialized BEFORE scheduler so warning is logged early if not configured

5. Signal handling ensures graceful shutdown waits for running jobs
  </action>
  <verify>go build ./cmd/...</verify>
  <done>Main.go compiles with scheduler and notifier integration, scheduled mode replaces TODO placeholder</done>
</task>

<task type="auto">
  <name>Task 2: Add unit test for scheduled mode flag handling</name>
  <files>cmd/main_test.go</files>
  <action>
Create basic unit tests for main.go in `cmd/main_test.go`:

1. TestVersionFlag - Verify --version exits immediately:
   - This is a simple smoke test
   - Can use exec.Command to run the binary with --version
   - Verify output contains version string
   - Skip if -short flag is set (integration test)

2. TestHelpFlag - Verify -h/--help shows usage:
   - Similar approach using exec.Command
   - Verify output contains "Usage:" or "Options:"

3. Note: Full scheduled mode testing is done via manual testing:
   - Manual Test 1: Run with -run-once flag
   - Manual Test 2: Run without flags (scheduled mode)
   - Manual Test 3: Verify graceful shutdown with Ctrl+C

4. Add build constraint if needed to skip tests that require subprocess execution

5. Keep tests minimal - main.go is mostly wiring, not complex logic
  </action>
  <verify>go test ./cmd/... -v -short</verify>
  <done>Basic tests pass for main entry point flag handling</done>
</task>

<task type="auto">
  <name>Task 3: Manual verification of scheduled mode</name>
  <files>N/A</files>
  <action>
Manual verification steps (document in SUMMARY):

1. Build the application:
   ```
   go build -o nanobot-auto-updater.exe ./cmd/main.go
   ```

2. Test scheduled mode startup:
   ```
   ./nanobot-auto-updater.exe
   ```
   - Verify log shows "Scheduler started" with cron expression
   - Verify log shows Pushover warning if env vars not set (expected)
   - Verify application does not exit (runs continuously)

3. Test graceful shutdown:
   - Press Ctrl+C
   - Verify log shows "Shutdown signal received"
   - Verify log shows "Scheduler stopped, all jobs completed"
   - Verify application exits cleanly

4. Test with custom cron (immediate trigger for testing):
   ```
   ./nanobot-auto-updater.exe -cron "* * * * *"
   ```
   - Wait 1 minute for job to trigger
   - Verify log shows "Starting scheduled update job"
   - Verify update executes (success or failure logged)
   - If failure: verify notification attempt logged

5. Document results in SUMMARY
  </action>
  <verify>Manual verification documented in SUMMARY</verify>
  <done>Scheduled mode verified working with startup, job execution, and graceful shutdown</done>
</task>

</tasks>

<verification>
Phase 3 Plan 03 verification:
1. Run `go build ./cmd/...` - must compile
2. Run `go test ./cmd/... -v -short` - tests pass
3. Verify main.go imports scheduler and notifier packages
4. Verify main.go no longer contains "TODO: Phase 3"
5. Verify main.go contains signal.Notify for graceful shutdown
6. Manual verification: scheduled mode runs and handles Ctrl+C gracefully
</verification>

<success_criteria>
- [ ] cmd/main.go updated with scheduler and notifier imports
- [ ] TODO: Phase 3 placeholder replaced with full implementation
- [ ] Notifier initialized before scheduler (early warning for missing config)
- [ ] Update job registered with scheduler using cfg.Cron
- [ ] On update failure: NotifyFailure called with operation and error
- [ ] Signal handling set up for SIGINT/SIGTERM
- [ ] sched.Start() called to begin scheduled execution
- [ ] sched.Stop() called on shutdown with context wait
- [ ] Manual verification of startup, job execution, and shutdown
</success_criteria>

<output>
After completion, create `.planning/phases/03-scheduling-and-notifications/03-03-SUMMARY.md`
</output>
