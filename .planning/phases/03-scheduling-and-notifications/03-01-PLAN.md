---
phase: 03-scheduling-and-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/scheduler/scheduler.go
  - internal/scheduler/scheduler_test.go
autonomous: true
requirements:
  - SCHD-01
  - SCHD-03

must_haves:
  truths:
    - "Scheduled jobs run according to the cron expression from configuration"
    - "Overlapping update jobs are skipped when previous job is still running"
    - "Scheduler logs skip events when jobs overlap"
  artifacts:
    - path: "internal/scheduler/scheduler.go"
      provides: "Scheduler wrapper with SkipIfStillRunning mode"
      contains: "cron.SkipIfStillRunning"
      min_lines: 60
    - path: "internal/scheduler/scheduler_test.go"
      provides: "Unit tests for scheduler"
      exports: ["TestNew", "TestAddJob", "TestStartStop"]
  key_links:
    - from: "internal/scheduler/scheduler.go"
      to: "robfig/cron/v3"
      via: "import and cron.New()"
      pattern: "cron\\.New\\(.*SkipIfStillRunning"
---

<objective>
Create scheduler package that wraps robfig/cron with SkipIfStillRunning mode to prevent job overlap.

Purpose: Enable scheduled execution of update jobs with automatic overlap prevention, ensuring only one update runs at a time.
Output: internal/scheduler/scheduler.go and scheduler_test.go
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/allan716/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scheduling-and-notifications/03-RESEARCH.md

# Existing patterns to follow
@internal/logging/logging.go - Logger creation pattern
@internal/updater/updater.go - Struct with logger field pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Scheduler struct with SkipIfStillRunning mode</name>
  <files>internal/scheduler/scheduler.go</files>
  <action>
Create the scheduler package with the following implementation:

1. Create `internal/scheduler/scheduler.go` with:
   - Scheduler struct holding *cron.Cron and *slog.Logger
   - New(logger *slog.Logger) function that:
     - Creates a cron.VerbosePrintfLogger from the slog.Logger with "component"="scheduler"
     - Initializes cron.New() with cron.WithChain(cron.SkipIfStillRunning(cronLogger)) and cron.WithLogger(cronLogger)
     - Returns *Scheduler
   - AddJob(cronExpr string, jobFunc func()) error method that:
     - Calls s.cron.AddFunc(cronExpr, jobFunc)
     - Logs "Job scheduled" at INFO level with schedule on success
     - Returns wrapped error on failure
   - Start() method that calls s.cron.Start() and logs "Starting scheduler"
   - Stop() method that:
     - Calls ctx := s.cron.Stop()
     - Waits for <-ctx.Done()
     - Logs "Scheduler stopped, all jobs completed"

2. CRITICAL: Use cron.VerbosePrintfLogger to wrap slog.Logger for cron.Logger compatibility

3. Pattern from RESEARCH.md Pattern 1:
```go
cronLogger := cron.VerbosePrintfLogger(logger.With("component", "scheduler"))
c := cron.New(
    cron.WithChain(cron.SkipIfStillRunning(cronLogger)),
    cron.WithLogger(cronLogger),
)
```

4. DO NOT pass slog.Logger directly to SkipIfStillRunning - this causes compilation error

5. Add go:build windows constraint (following lifecycle package pattern)
  </action>
  <verify>go build ./internal/scheduler/...</verify>
  <done>Scheduler struct compiles with SkipIfStillRunning mode, New/AddJob/Start/Stop methods implemented</done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for scheduler</name>
  <files>internal/scheduler/scheduler_test.go</files>
  <action>
Create comprehensive unit tests in `internal/scheduler/scheduler_test.go`:

1. TestNew - Verify scheduler is created correctly:
   - Create logger using logging.NewLogger("./logs")
   - Call scheduler.New(logger)
   - Verify returned scheduler is not nil

2. TestAddJob - Verify job registration:
   - Create scheduler
   - Call AddJob with valid cron expression "*/5 * * * *"
   - Verify no error returned

3. TestAddJobInvalidCron - Verify error on invalid expression:
   - Create scheduler
   - Call AddJob with invalid expression "invalid"
   - Verify error is returned

4. TestStartStop - Verify lifecycle:
   - Create scheduler with a job that sets a flag
   - Call Start()
   - Call Stop()
   - Verify function returns without panic

5. Use testing.Short() to skip integration-style tests

6. Pattern from existing tests (e.g., updater_test.go):
   - Use slog.Default() or create test logger
   - Keep tests focused and fast
  </action>
  <verify>go test ./internal/scheduler/... -v</verify>
  <done>All tests pass, code coverage includes New, AddJob, Start, Stop methods</done>
</task>

</tasks>

<verification>
Phase 3 Plan 01 verification:
1. Run `go build ./internal/scheduler/...` - must compile
2. Run `go test ./internal/scheduler/... -v` - all tests pass
3. Verify scheduler.go contains cron.SkipIfStillRunning
4. Verify scheduler.go uses cron.VerbosePrintfLogger for logger adaptation
</verification>

<success_criteria>
- [ ] internal/scheduler/scheduler.go exists with Scheduler struct
- [ ] New() creates scheduler with SkipIfStillRunning wrapper
- [ ] AddJob() registers jobs and validates cron expressions
- [ ] Start()/Stop() methods handle scheduler lifecycle
- [ ] Stop() waits for running jobs via context
- [ ] Unit tests pass for all public methods
- [ ] Code uses cron.VerbosePrintfLogger for slog compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/03-scheduling-and-notifications/03-01-SUMMARY.md`
</output>
