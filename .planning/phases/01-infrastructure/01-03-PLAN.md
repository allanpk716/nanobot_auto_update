---
phase: 01-infrastructure
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
  - 01-02
files_modified:
  - cmd/main.go
  - go.mod
  - config.yaml
autonomous: true
requirements:
  - INFR-05
  - INFR-06
  - INFR-07
  - INFR-08
  - INFR-09

must_haves:
  truths:
    - "User can run program with -help and see usage information"
    - "User can run program with -version and see version info"
    - "User can specify config file path with -config flag"
    - "User can override cron expression with -cron flag"
    - "User can run one-time update with -run-once flag"
    - "CLI flags override config file values"
    - "Program exits immediately after -help or -version"
  artifacts:
    - path: "cmd/main.go"
      provides: "Application entry point with CLI parsing"
      exports:
        - "main"
      min_lines: 80
    - path: "config.yaml"
      provides: "Default configuration file"
      contains: "cron:"
    - path: "go.mod"
      provides: "Dependency declarations"
      contains: "pflag"
  key_links:
    - from: "cmd/main.go"
      to: "github.com/spf13/pflag"
      via: "import"
      pattern: "flag\\."
    - from: "cmd/main.go"
      to: "github.com/spf13/viper"
      via: "BindPFlag"
      pattern: "viper\\.BindPFlag"
    - from: "cmd/main.go"
      to: "internal/logging"
      via: "import"
      pattern: "logging\\.NewLogger"
    - from: "cmd/main.go"
      to: "internal/config"
      via: "import"
      pattern: "config\\.Load"
---

<objective>
Create the application entry point with CLI flag parsing, configuration loading, and logger initialization.

Purpose: Enable users to control the application via command-line flags with proper precedence (flags > config > defaults).
Output: `cmd/main.go` with full CLI parsing, config loading integration, and logger setup.
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/allan716/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/1-RESEARCH.md

# Dependencies from prior plans
@internal/logging/logging.go - NewLogger function
@internal/config/config.go - Load function, Config struct

# RESEARCH patterns to follow
- Use pflag for POSIX-style flags
- Use viper.BindPFlag for flag-config integration
- Handle --version and --help with early exit
- Create logs directory before logger initialization
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pflag dependency to go.mod</name>
  <files>go.mod</files>
  <action>
Add the pflag dependency using `go get`:

```bash
go get github.com/spf13/pflag@latest
```

This will update go.mod and go.sum.
  </action>
  <verify>
```bash
grep pflag go.mod
```
Should show pflag in require section.
  </verify>
  <done>go.mod contains pflag dependency.</done>
</task>

<task type="auto">
  <name>Task 2: Update config.yaml with cron field</name>
  <files>config.yaml</files>
  <action>
Update `config.yaml` to include the cron field:

```yaml
# Nanobot Auto Updater Configuration

# Cron schedule for automatic updates (default: daily at 3 AM)
cron: "0 3 * * *"

nanobot:
  port: 18790
  startup_timeout: 30s
```

Keep existing nanobot section and add cron field at the top with comment.
  </action>
  <verify>
```bash
cat config.yaml
```
Shows cron field with default value.
  </verify>
  <done>config.yaml contains cron field with default "0 3 * * *".</done>
</task>

<task type="auto">
  <name>Task 3: Create main entry point with CLI and integration</name>
  <files>cmd/main.go</files>
  <action>
Create `cmd/main.go` with complete application entry point:

1. Package: `main`

2. Version constant:
```go
var (
    Version = "dev" // Set via ldflags at build time
)
```

3. CLI flags using pflag:
```go
import (
    flag "github.com/spf13/pflag"
)

func main() {
    // Define flags
    configFile := flag.String("config", "./config.yaml", "Path to config file")
    cronExpr := flag.String("cron", "", "Cron expression (overrides config file)")
    runOnce := flag.Bool("run-once", false, "Run update once and exit")
    showVersion := flag.Bool("version", false, "Show version information")
    flag.BoolP("help", "h", false, "Show help")

    flag.Parse()

    // Handle --version (exit immediately)
    if *showVersion {
        fmt.Printf("nanobot-auto-updater %s\n", Version)
        os.Exit(0)
    }

    // Handle --help (exit immediately)
    if help, _ := flag.CommandLine.GetBool("help"); help {
        fmt.Println("Usage: nanobot-auto-updater [options]")
        fmt.Println("\nOptions:")
        flag.PrintDefaults()
        os.Exit(0)
    }
```

4. Load configuration with CLI override support:
```go
    // Load config
    cfg, err := config.Load(*configFile)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
        os.Exit(1)
    }

    // Override cron from CLI flag if provided
    if *cronExpr != "" {
        if err := config.ValidateCron(*cronExpr); err != nil {
            fmt.Fprintf(os.Stderr, "Error: %v\n", err)
            os.Exit(1)
        }
        cfg.Cron = *cronExpr
    }
```

5. Initialize logger:
```go
    // Create logs directory
    if err := os.MkdirAll("./logs", 0755); err != nil {
        fmt.Fprintf(os.Stderr, "Error creating logs directory: %v\n", err)
        os.Exit(1)
    }

    // Initialize logger
    logger := logging.NewLogger("./logs")
    slog.SetDefault(logger) // Set as default logger

    logger.Info("Application starting",
        "version", Version,
        "config", *configFile,
        "cron", cfg.Cron,
        "run_once", *runOnce,
    )
```

6. Placeholder for main logic (future phases):
```go
    // TODO: Phase 2 - Implement update logic
    // TODO: Phase 3 - Implement scheduling
    // For now, just log and exit
    logger.Info("Infrastructure phase complete - no update logic yet")

    if *runOnce {
        logger.Info("Run-once mode - would execute update here")
        // Future: execute update and exit
    }
```

Imports needed:
- fmt
- log/slog
- os
- github.com/spf13/pflag (aliased as flag)
- github.com/{module}/internal/config
- github.com/{module}/internal/logging

Note: Use the module name from go.mod: `github.com/HQGroup/nanobot-auto-updater`
  </action>
  <verify>
```bash
go build -o nanobot-auto-updater.exe ./cmd/main.go
./nanobot-auto-updater.exe -help
./nanobot-auto-updater.exe -version
```
Both commands work correctly.
  </verify>
  <done>cmd/main.go compiles and responds to -help and -version flags.</done>
</task>

<task type="auto">
  <name>Task 4: Verify CLI flag precedence and integration</name>
  <files>cmd/main.go (add integration test)</files>
  <action>
Manually test the complete flow:

1. Test default config loading:
```bash
go run ./cmd/main.go
```
Should log: cron="0 3 * * *", config="./config.yaml"

2. Test --cron override:
```bash
go run ./cmd/main.go -cron "*/5 * * * *"
```
Should log: cron="*/5 * * * *" (overridden)

3. Test --config flag:
```bash
echo 'cron: "0 5 * * *"' > /tmp/test-config.yaml
go run ./cmd/main.go -config /tmp/test-config.yaml
```
Should log: cron="0 5 * * *" (from test config)

4. Test --run-once flag:
```bash
go run ./cmd/main.go -run-once
```
Should log: run_once=true

5. Test invalid cron:
```bash
go run ./cmd/main.go -cron "invalid" 2>&1
```
Should exit with error about invalid cron expression

6. Test -h/--help:
```bash
go run ./cmd/main.go -h
go run ./cmd/main.go --help
```
Both should show usage information

7. Test --version:
```bash
go run ./cmd/main.go --version
```
Should show version and exit immediately

Document these tests in a comment at the bottom of main.go for reference.
  </action>
  <verify>
All manual tests pass as described above.
  </verify>
  <done>All CLI flags work correctly with proper precedence (flags > config > defaults).</done>
</task>

</tasks>

<verification>
1. Run `go build ./...` to ensure all code compiles
2. Run `go run ./cmd/main.go -help` shows usage
3. Run `go run ./cmd/main.go -version` shows version
4. Run `go run ./cmd/main.go` loads config and initializes logger
5. Verify config.yaml has cron field
6. Verify logs directory is created and app.log exists after run
</verification>

<success_criteria>
- cmd/main.go compiles and runs
- -help shows usage with all flags documented
- -version shows version and exits
- -config allows custom config path
- -cron overrides config file cron value
- -run-once sets run_once mode
- Config loaded from YAML file
- Logger initialized with custom format
- Flag precedence: CLI > config file > defaults
- Logs written to ./logs/app.log
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-03-SUMMARY.md`
</output>
