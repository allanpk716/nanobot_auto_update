---
phase: 04-runtime-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Makefile
autonomous: false
requirements:
  - RUN-01
  - RUN-02

must_haves:
  truths:
    - "User can build a release executable that runs without console window"
    - "User can build a debug executable that shows console for development"
    - "Release build starts silently when double-clicked in Windows Explorer"
    - "Release build can be started manually from command line without auto-start"
    - "Log files in ./logs/ directory verify application ran correctly"
  artifacts:
    - path: "Makefile"
      provides: "Build targets for console and GUI subsystem builds"
      min_lines: 30
  key_links:
    - from: "Makefile"
      to: "go build command"
      via: "ldflags -H=windowsgui"
      pattern: "-H=windowsgui"
---

<objective>
Create a Makefile with build targets for both console (debug) and GUI (release) subsystem builds. The release build will use Go linker flags to set the PE subsystem to Windows GUI, preventing console window allocation on startup.

Purpose: Enable Windows background execution without visible console window for production use, while maintaining console builds for debugging.
Output: Makefile with `build`, `build-release`, `test`, `clean`, and `help` targets
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/allan716/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-runtime-integration/04-RESEARCH.md

## Key Context from Research

The research document (04-RESEARCH.md) confirms:
1. **Build-time only solution**: Hiding console window is achieved through Go linker flags (`-ldflags="-H=windowsgui"`). No code changes required.
2. **PE Subsystem Mechanism**: Sets PE subsystem to "Windows GUI" (value 2) instead of "Console" (value 3).
3. **Project already prepared**: Existing codebase correctly uses `windows.SysProcAttr` with `HideWindow` for child processes.
4. **Not a Windows Service**: Just GUI subsystem executable for manual start - no service registration needed.

## Existing Project Structure
```
nanobot_auto_update/
├── cmd/
│   └── main.go           # Already has Version variable for ldflags
├── internal/
│   ├── lifecycle/        # Uses SysProcAttr correctly
│   ├── updater/          # Uses SysProcAttr correctly
│   ├── config/
│   ├── logging/          # File-based logging (no console dependency)
│   ├── scheduler/
│   └── notifier/
├── go.mod
└── go.sum
```

The main.go already has `var Version = "dev"` ready for ldflags embedding.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Makefile with build and build-release targets</name>
  <files>Makefile</files>
  <action>
Create a Makefile at the project root with the following targets:

1. **build** target: Console version for debugging
   - Command: `go build -o nanobot-auto-updater.exe ./cmd`
   - Echo message indicating console version built

2. **build-release** target: GUI subsystem for production (no console window)
   - Version extraction from git: `git describe --tags --always --dirty 2>/dev/null || echo "dev"`
   - LDFLAGS: `-H=windowsgui -X main.Version=$(VERSION)`
   - Command: `go build -ldflags="$(LDFLAGS_RELEASE)" -o nanobot-auto-updater.exe ./cmd`
   - Echo message indicating release version built (no console)

3. **clean** target: Remove build artifacts
   - Remove nanobot-auto-updater.exe
   - Echo confirmation

4. **test** target: Run all tests
   - Command: `go test ./...`

5. **help** target: Show available commands
   - List all targets with descriptions
   - Show VERSION variable usage

Include `.PHONY` declaration for all targets.

Reference the research document Pattern 2 for the complete Makefile example. Use tabs for recipe indentation (Makefile requirement).
  </action>
  <verify>
Run the following commands to verify:
1. `make build` - should create nanobot-auto-updater.exe (console version)
2. `make build-release` - should create nanobot-auto-updater.exe (GUI version)
3. `./nanobot-auto-updater.exe --version` - should return exit code 0
4. `make help` - should display usage information
5. `make clean` - should remove the executable
  </verify>
  <done>
Makefile exists at project root with working build, build-release, clean, test, and help targets. Running `make build-release` produces a Windows executable that runs without displaying a console window.
</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify console window hiding and manual start behavior</name>
  <what-built>
Makefile with two build targets:
1. `make build` - Console version for debugging (shows window when run)
2. `make build-release` - GUI version for production (no console window)
  </what-built>
  <how-to-verify>
## Verification Steps for RUN-01 (Hide Console Window)

**Step 1: Build the release version**
```bash
cd C:/WorkSpace/agent/nanobot_auto_update
make build-release
```

**Step 2: Verify no console window on double-click**
1. Open Windows Explorer
2. Navigate to `C:/WorkSpace/agent/nanobot_auto_update`
3. Double-click `nanobot-auto-updater.exe`
4. **Expected**: No console window appears (application starts silently)
5. Check `./logs/` directory for log files confirming startup

**Step 3: Verify console build still works**
```bash
make build
./nanobot-auto-updater.exe --version
```
**Expected**: Version string printed to console (e.g., "nanobot-auto-updater dev")

**Step 4: Verify release build from command line**
```bash
make build-release
./nanobot-auto-updater.exe --version
echo $?
```
**Expected**: No output displayed (GUI binary has no stdout), exit code 0

## Verification for RUN-02 (Manual Start)

**Step 5: Confirm no auto-start**
Reboot the computer and verify nanobot-auto-updater.exe does NOT start automatically. The application only runs when explicitly started by user.
  </how-to-verify>
  <resume-signal>Type "approved" if verification passes, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Phase 4 verification criteria:

1. **RUN-01 (Hide Console Window)**:
   - `make build-release` produces executable with GUI subsystem
   - Double-clicking executable in Explorer does NOT show console window
   - Application writes logs to ./logs/ directory (verifiable output)
   - `make build` still produces console version for debugging

2. **RUN-02 (Manual Start)**:
   - No Windows service registration (just GUI subsystem binary)
   - No auto-start mechanism (user must manually run executable)
   - Application runs when explicitly started by user

3. **Backward Compatibility**:
   - All features from previous phases work in background mode
   - Scheduled updates continue to function
   - Notifications are sent on failures
   - Log files capture all output
</verification>

<success_criteria>
1. Makefile exists at project root with build and build-release targets
2. Running `make build-release` creates nanobot-auto-updater.exe that runs without console window
3. Running `make build` creates console version for debugging (shows --help, --version output)
4. User can start the release executable manually from Explorer or command line
5. No auto-start mechanism is implemented (requirement RUN-02)
6. All log output goes to ./logs/ directory (not console) in release build
</success_criteria>

<output>
After completion, create `.planning/phases/04-runtime-integration/04-01-SUMMARY.md`
</output>
