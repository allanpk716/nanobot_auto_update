# Phase 01.1: Nanobot Lifecycle Management - Research

**Researched:** 2025-02-18
**Domain:** Windows process lifecycle management in Go (stop/start by port detection)
**Confidence:** MEDIUM (WebSearch unavailable, based on training data + official package docs)

## Summary

This phase requires managing the nanobot process lifecycle: detecting if nanobot is running by checking port 18790, stopping it gracefully before updates, and restarting it after updates complete. On Windows, this involves specific challenges: Unix signals like SIGTERM are not available, process termination requires Windows API calls or external tools, and starting background processes without visible windows requires proper `SysProcAttr` configuration.

**Primary recommendation:** Use `github.com/shirou/gopsutil/v3/net` to detect processes by port, implement graceful shutdown via `taskkill` command (Windows tool) with 5-second timeout before force kill, and start nanobot using `exec.Command` with `CREATE_NO_WINDOW` flag.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### 进程检测
- 通过检测端口监听状态判断 nanobot 是否运行
- 默认检测端口 18790
- 端口号可在配置文件中自定义

#### 停止行为
- 优雅停止 + 超时强制终止
- 先发送终止信号等待进程正常退出
- 超时时间：5 秒，超时后强制终止进程

#### 启动行为
- 更新后总是启动 nanobot（不管更新前是否运行）
- 启动命令：`nanobot gateway`
- 完全静默启动，不显示控制台窗口
- 使用系统默认目录启动
- 不需要额外的命令行参数
- 通过检查端口监听确认启动成功
- 启动超时时间可配置

#### 失败处理
- 停止失败：取消本次更新，记录错误日志
- 启动失败：更新仍然视为成功，记录错误日志（用户可手动启动）

#### 日志记录
- 记录所有操作的时间戳
- 记录执行的命令及返回结果
- 记录端口状态和进程 ID
- 停止/启动失败时记录详细错误信息（包含错误码）

#### 配置结构
- nanobot 相关配置放在独立 section 中
- 配置项包括：端口、启动超时时间等

### Claude's Discretion
- 具体的进程终止信号选择（SIGTERM/SIGKILL 等）
- 端口检测的具体实现方式
- 日志格式细节

### Deferred Ideas (OUT OF SCOPE)
None - 讨论保持在阶段范围内
</user_constraints>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| **gopsutil/net** | v3 (github.com/shirou/gopsutil/v3/net) | Detect process by listening port | Cross-platform, mature library with 10k+ stars. Provides `ConnectionStat` with PID and port information. Avoids parsing netstat output manually. |
| **os/exec** | stdlib | Execute taskkill and nanobot commands | Standard Go way to spawn processes. Use with SysProcAttr for hidden windows. |
| **syscall** | stdlib | Windows-specific process creation flags | Required for CREATE_NO_WINDOW, CREATE_NEW_PROCESS_GROUP flags. |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| **context** | stdlib | Timeout control for graceful shutdown | Use with context.WithTimeout for the 5-second stop timeout |
| **time** | stdlib | Sleep/duration for startup verification | Use time.Sleep for polling port availability after start |
| **net** | stdlib | TCP dial for port verification | Use net.DialTimeout to verify nanobot started successfully |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| gopsutil/net | netstat command parsing | netstat output format varies by Windows version. gopsutil provides stable API but adds dependency. |
| gopsutil/net | Windows GetTcpTable2 API | Lower level, no external dependency, but requires more code and CGO understanding. |
| taskkill command | syscall.TerminateProcess | syscall.TerminateProcess is force-only, no graceful option. taskkill allows WM_CLOSE message first. |
| taskkill command | golang.org/x/sys/windows API | More control but complex. taskkill is simpler and handles graceful termination automatically. |

**Installation:**
```bash
go get github.com/shirou/gopsutil/v3/net
```

## Architecture Patterns

### Recommended Project Structure
```
internal/
├── lifecycle/           # New package for this phase
│   ├── detector.go      # Port-based process detection
│   ├── stopper.go       # Graceful + force stop logic
│   ├── starter.go       # Background process startup
│   └── manager.go       # Orchestrates stop/start around updates
├── config/
│   └── config.go        # Add nanobot section (port, startup_timeout)
```

### Pattern 1: Process Detection by Port
**What:** Use gopsutil/net to find PID of process listening on specified port.
**When to use:** When you need to detect if nanobot is running before attempting stop.

**Example:**
```go
package lifecycle

import (
    "fmt"
    "github.com/shirou/gopsutil/v3/net"
)

// FindPIDByPort returns the PID of the process listening on the specified port.
// Returns 0 if no process is listening on that port.
func FindPIDByPort(port uint32) (int32, error) {
    connections, err := net.Connections("tcp")
    if err != nil {
        return 0, fmt.Errorf("failed to get network connections: %w", err)
    }

    for _, conn := range connections {
        // Check if connection is listening on the specified port
        if conn.Status == "LISTEN" && conn.Laddr.Port == port {
            return conn.Pid, nil
        }
    }

    return 0, nil // No process found, not an error
}

// IsNanobotRunning checks if nanobot is running on the specified port
func IsNanobotRunning(port uint32) (bool, int32, error) {
    pid, err := FindPIDByPort(port)
    if err != nil {
        return false, 0, err
    }
    return pid > 0, pid, nil
}
```
**Source:** [gopsutil/net pkg.go.dev](https://pkg.go.dev/github.com/shirou/gopsutil/v3/net)

### Pattern 2: Graceful Stop with Timeout (Windows)
**What:** Use taskkill for graceful shutdown, then force kill after timeout.
**When to use:** On Windows where SIGTERM is not available.

**Example:**
```go
package lifecycle

import (
    "context"
    "fmt"
    "os/exec"
    "syscall"
    "time"
)

// StopNanobot gracefully stops nanobot process, force-killing after timeout.
// Returns error if stop fails completely.
func StopNanobot(ctx context.Context, pid int32, timeout time.Duration) error {
    if pid <= 0 {
        return nil // Nothing to stop
    }

    // Create timeout context for the entire stop operation
    stopCtx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()

    // Step 1: Try graceful termination (taskkill without /f)
    // This sends WM_CLOSE message to the process
    gracefulCmd := exec.CommandContext(stopCtx, "taskkill", "/PID", fmt.Sprintf("%d", pid))
    gracefulCmd.SysProcAttr = &syscall.SysProcAttr{
        HideWindow:    true,
        CreationFlags: syscall.CREATE_NO_WINDOW,
    }

    err := gracefulCmd.Run()
    if err == nil {
        // Graceful termination succeeded, wait for process to exit
        if waitForProcessExit(stopCtx, pid, 2*time.Second) {
            return nil
        }
    }

    // Step 2: Force kill (taskkill /f)
    forceCmd := exec.CommandContext(stopCtx, "taskkill", "/F", "/PID", fmt.Sprintf("%d", pid))
    forceCmd.SysProcAttr = &syscall.SysProcAttr{
        HideWindow:    true,
        CreationFlags: syscall.CREATE_NO_WINDOW,
    }

    if err := forceCmd.Run(); err != nil {
        return fmt.Errorf("force kill failed: %w", err)
    }

    // Verify process is gone
    if !waitForProcessExit(stopCtx, pid, 1*time.Second) {
        return fmt.Errorf("process %d did not terminate after force kill", pid)
    }

    return nil
}

// waitForProcessExit polls until the process exits or context is done
func waitForProcessExit(ctx context.Context, pid int32, pollInterval time.Duration) bool {
    ticker := time.NewTicker(pollInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return false
        case <-ticker.C:
            // Check if process still exists
            process, err := os.FindProcess(int(pid))
            if err != nil {
                return true // Process doesn't exist
            }
            // On Windows, FindProcess always succeeds, so we try to signal
            err = process.Signal(syscall.Signal(0))
            if err != nil {
                return true // Process has exited
            }
        }
    }
}
```

### Pattern 3: Silent Background Process Startup
**What:** Start nanobot gateway as a detached, hidden background process.
**When to use:** When starting nanobot after an update completes.

**Example:**
```go
package lifecycle

import (
    "context"
    "fmt"
    "net"
    "os/exec"
    "syscall"
    "time"
)

// StartNanobot starts nanobot gateway in the background with hidden window.
// Returns error if startup fails or port is not listening within timeout.
func StartNanobot(ctx context.Context, port uint32, startupTimeout time.Duration) error {
    // Start nanobot gateway as background process
    cmd := exec.Command("nanobot", "gateway")
    cmd.SysProcAttr = &syscall.SysProcAttr{
        HideWindow:    true,
        CreationFlags: syscall.CREATE_NO_WINDOW | syscall.CREATE_NEW_PROCESS_GROUP,
    }

    // Detach from parent - don't wait for completion
    if err := cmd.Start(); err != nil {
        return fmt.Errorf("failed to start nanobot: %w", err)
    }

    // Release the process so it continues independently
    if err := cmd.Process.Release(); err != nil {
        return fmt.Errorf("failed to detach nanobot process: %w", err)
    }

    // Verify startup by checking port becomes available
    if err := waitForPortListening(ctx, port, startupTimeout); err != nil {
        return fmt.Errorf("nanobot startup verification failed: %w", err)
    }

    return nil
}

// waitForPortListening polls until the port is listening or timeout
func waitForPortListening(ctx context.Context, port uint32, timeout time.Duration) error {
    deadline := time.Now().Add(timeout)
    address := fmt.Sprintf("127.0.0.1:%d", port)

    for time.Now().Before(deadline) {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            // Try to connect to verify port is listening
            conn, err := net.DialTimeout("tcp", address, 1*time.Second)
            if err == nil {
                conn.Close()
                return nil // Port is listening
            }
            time.Sleep(500 * time.Millisecond)
        }
    }

    return fmt.Errorf("port %d not listening after %v", port, timeout)
}
```

### Pattern 4: Lifecycle Manager Integration
**What:** Orchestrates stop-update-start sequence with proper error handling.
**When to use:** As the main entry point called by the update logic.

**Example:**
```go
package lifecycle

import (
    "context"
    "fmt"
    "time"
)

type Manager struct {
    port           uint32
    startupTimeout time.Duration
    stopTimeout    time.Duration
}

type Config struct {
    Port           uint32        `yaml:"port"`
    StartupTimeout time.Duration `yaml:"startup_timeout"`
}

func NewManager(cfg Config) *Manager {
    return &Manager{
        port:           cfg.Port,
        startupTimeout: cfg.StartupTimeout,
        stopTimeout:    5 * time.Second, // Locked decision
    }
}

// StopForUpdate stops nanobot before update. Returns error if stop fails.
func (m *Manager) StopForUpdate(ctx context.Context) error {
    running, pid, err := IsNanobotRunning(m.port)
    if err != nil {
        return fmt.Errorf("failed to detect nanobot: %w", err)
    }

    if !running {
        // Not running, nothing to stop
        return nil
    }

    if err := StopNanobot(ctx, pid, m.stopTimeout); err != nil {
        return fmt.Errorf("failed to stop nanobot (PID %d): %w", pid, err)
    }

    return nil
}

// StartAfterUpdate starts nanobot after update. Logs error but doesn't fail update.
func (m *Manager) StartAfterUpdate(ctx context.Context) error {
    // Always start regardless of previous state (locked decision)
    if err := StartNanobot(ctx, m.port, m.startupTimeout); err != nil {
        // Log error but don't fail - update is still successful
        return fmt.Errorf("failed to start nanobot (user can start manually): %w", err)
    }
    return nil
}
```

### Anti-Patterns to Avoid

- **Using syscall.SIGTERM on Windows:** Windows does not support Unix signals. Use taskkill or Windows API instead.
- **Forgetting SysProcAttr.HideWindow:** Child processes will flash console windows.
- **Blocking on cmd.Run() for background processes:** Use cmd.Start() + cmd.Process.Release() for detached processes.
- **Not verifying startup:** Starting a process doesn't mean it's ready. Always verify port is listening.
- **Hardcoding timeout:** Make startup timeout configurable via config file.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Parse netstat output | Regex/string parsing of `netstat -ano` | gopsutil/net.Connections() | Output format varies by Windows version, locale. gopsutil handles edge cases. |
| Implement port scanning | Manual TCP dial loop | net.DialTimeout with retry | DialTimeout handles timeouts correctly, easy to use. |
| Process signal handling | os.Process.Signal(SIGTERM) | taskkill command | SIGTERM doesn't work on Windows. taskkill sends WM_CLOSE for graceful shutdown. |
| Find process by PID | Manual process enumeration | os.FindProcess + Signal(0) | Simpler and more reliable than custom enumeration. |

**Key insight:** Windows process management is fundamentally different from Unix. Don't try to port Unix signal patterns - use Windows-native tools like taskkill.

## Common Pitfalls

### Pitfall 1: Windows Signal Support Misconception
**What goes wrong:** Developers try to use `syscall.SIGTERM` or `syscall.SIGINT` on Windows, expecting graceful shutdown behavior like Unix.
**Why it happens:** Go's signal package compiles but signals work differently on Windows - SIGTERM becomes a hard kill.
**How to avoid:** Use `taskkill` command (graceful via WM_CLOSE) or implement application-specific shutdown mechanism (HTTP endpoint, named pipe).
**Warning signs:** Code using `process.Signal(syscall.SIGTERM)` on Windows.

### Pitfall 2: Console Window Flashing
**What goes wrong:** Starting nanobot creates a visible console window that briefly appears before disappearing.
**Why it happens:** Default `exec.Command` creates a new console window on Windows unless explicitly hidden.
**How to avoid:** Always set `SysProcAttr` with `HideWindow: true` and `CreationFlags: syscall.CREATE_NO_WINDOW`.
**Warning signs:** No SysProcAttr configuration for exec.Command calls.

### Pitfall 3: Startup Race Condition
**What goes wrong:** Assuming process start means service is ready - subsequent operations fail because port isn't listening yet.
**Why it happens:** Process startup takes time; the port isn't bound immediately after cmd.Start() returns.
**How to avoid:** Poll the port with timeout until connection succeeds or timeout expires.
**Warning signs:** No verification after cmd.Start(), assuming immediate availability.

### Pitfall 4: Detached Process Becomes Zombie
**What goes wrong:** Started process doesn't survive after parent exits because it wasn't properly detached.
**Why it happens:** Default behavior keeps parent-child relationship; child terminates when parent does.
**How to avoid:** Use `CREATE_NEW_PROCESS_GROUP` flag and call `cmd.Process.Release()` after `cmd.Start()`.
**Warning signs:** Using `cmd.Run()` for background processes, not calling Release().

### Pitfall 5: Stale PID Reference
**What goes wrong:** PID obtained from port detection is stale - process exited and PID was reused.
**Why it happens:** Time gap between port detection and kill attempt; PIDs can be reused quickly on Windows.
**How to avoid:** Verify process still owns the port before killing, or accept that killing wrong process is unlikely (small time window).
**Warning signs:** Long delays between port detection and process termination.

## Code Examples

### Complete Stop-Update-Start Flow

```go
package updater

import (
    "context"
    "fmt"
    "log"
    "time"

    "nanobot-auto-update/internal/lifecycle"
)

type Updater struct {
    lifecycle *lifecycle.Manager
}

func (u *Updater) RunUpdate(ctx context.Context) error {
    const port = 18790

    // Step 1: Stop nanobot before update
    log.Printf("Checking if nanobot is running on port %d...", port)

    if err := u.lifecycle.StopForUpdate(ctx); err != nil {
        // Stop failure = cancel update (locked decision)
        return fmt.Errorf("update cancelled: %w", err)
    }

    log.Printf("Nanobot stopped successfully")

    // Step 2: Run the actual update (delegated to existing update logic)
    if err := u.performUpdate(ctx); err != nil {
        return fmt.Errorf("update failed: %w", err)
    }

    log.Printf("Update completed successfully")

    // Step 3: Start nanobot after update
    // Always attempt start regardless of previous state (locked decision)
    if err := u.lifecycle.StartAfterUpdate(ctx); err != nil {
        // Log error but don't fail - update is still successful
        log.Printf("WARNING: %v", err)
        // Return nil - update succeeded, just startup failed
        return nil
    }

    log.Printf("Nanobot started successfully on port %d", port)
    return nil
}

func (u *Updater) performUpdate(ctx context.Context) error {
    // Existing update logic (uv tool upgrade nanobot, etc.)
    return nil
}
```

### Configuration Structure

```go
package config

import "time"

type Config struct {
    // ... existing fields ...

    Nanobot NanobotConfig `yaml:"nanobot"`
}

type NanobotConfig struct {
    Port           uint32        `yaml:"port" mapstructure:"port"`
    StartupTimeout time.Duration `yaml:"startup_timeout" mapstructure:"startup_timeout"`
}

func defaults() Config {
    return Config{
        Nanobot: NanobotConfig{
            Port:           18790,            // Default nanobot port
            StartupTimeout: 30 * time.Second, // Default startup timeout
        },
    }
}

func (c *NanobotConfig) Validate() error {
    if c.Port == 0 {
        return errors.New("nanobot.port cannot be 0")
    }
    if c.Port > 65535 {
        return errors.New("nanobot.port must be <= 65535")
    }
    if c.StartupTimeout < 5*time.Second {
        return errors.New("nanobot.startup_timeout must be at least 5 seconds")
    }
    return nil
}
```

Example config.yaml:
```yaml
# Existing config fields
cron: "0 3 * * *"

# Nanobot lifecycle configuration
nanobot:
  port: 18790                    # Port to detect nanobot process
  startup_timeout: 30s           # Max time to wait for nanobot to start
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Parse netstat output | Use gopsutil library | ~2018+ | More reliable, cross-platform |
| os.Process.Kill() | taskkill with graceful option | Always | Allows graceful shutdown on Windows |
| cmd.Run() for services | cmd.Start() + Release() | Always | Proper detached process management |

**Deprecated/outdated:**
- `os.Process.Signal(syscall.SIGTERM)` on Windows: Does not work as expected. Use taskkill instead.
- Parsing netstat output manually: Fragile, locale-dependent. Use gopsutil.

## Open Questions

1. **Should we check if process on port is actually nanobot?**
   - What we know: gopsutil returns PID of any process on the port
   - What's unclear: Could another process be on port 18790?
   - Recommendation: Accept the risk for v1. Port 18790 is nanobot-specific. Add process name verification in future if needed.

2. **What if nanobot gateway command changes?**
   - What we know: Command is currently `nanobot gateway`
   - What's unclear: Future compatibility
   - Recommendation: Make command configurable in config file for forward compatibility.

## Sources

### Primary (HIGH confidence)
- [gopsutil/net pkg.go.dev](https://pkg.go.dev/github.com/shirou/gopsutil/v3/net) - API documentation for ConnectionStat and port detection
- [os/exec pkg.go.dev](https://pkg.go.dev/os/exec) - Official Go documentation for command execution
- [syscall pkg.go.dev](https://pkg.go.dev/syscall) - Windows-specific constants (CREATE_NO_WINDOW, etc.)
- Project RESEARCH files - Existing pitfalls and stack research

### Secondary (MEDIUM confidence)
- Existing PITFALLS.md research - SysProcAttr.HideWindow pattern
- Existing STACK.md research - WQGroup/logger integration

### Tertiary (LOW confidence)
- WebSearch results were unavailable, some patterns based on training knowledge

## Metadata

**Confidence breakdown:**
- Standard stack: MEDIUM - gopsutil is well-documented, WebSearch was unavailable for verification
- Architecture: MEDIUM - Patterns based on training data + project context, not verified with current docs
- Pitfalls: HIGH - Consistent with existing project research in PITFALLS.md

**Research date:** 2025-02-18
**Valid until:** 30 days (stable APIs, but gopsutil versions may change)
