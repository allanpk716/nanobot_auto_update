---
phase: 01.1-nanobot-lifecycle-management-stop-before-update-start-after-update
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/lifecycle/stopper.go
  - internal/lifecycle/starter.go
autonomous: true
requirements:
  - IMPL-02
  - IMPL-03
  - IMPL-04
user_setup: []

must_haves:
  truths:
    - "Nanobot process can be stopped gracefully with 5-second timeout"
    - "If graceful stop fails, process is force-killed"
    - "Nanobot gateway starts with hidden window (no console flash)"
    - "Startup success is verified by checking port is listening"
  artifacts:
    - path: "internal/lifecycle/stopper.go"
      provides: "Graceful and forced process termination"
      exports: ["StopNanobot"]
    - path: "internal/lifecycle/starter.go"
      provides: "Hidden background process startup with verification"
      exports: ["StartNanobot"]
  key_links:
    - from: "internal/lifecycle/stopper.go"
      to: "taskkill command"
      via: "exec.Command with SysProcAttr"
      pattern: "taskkill.*PID"
    - from: "internal/lifecycle/starter.go"
      to: "nanobot gateway"
      via: "exec.Command with CREATE_NO_WINDOW"
      pattern: "CREATE_NO_WINDOW"
    - from: "internal/lifecycle/starter.go"
      to: "port verification"
      via: "net.DialTimeout"
      pattern: "DialTimeout"
---

<objective>
Implement nanobot process stopping (graceful + force) and starting (hidden background with verification).

Purpose: Enable stopping nanobot before updates with graceful timeout, and starting nanobot after updates with hidden window and port verification.
Output: stopper.go with StopNanobot, starter.go with StartNanobot and waitForPortListening.
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/allan716/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-CONTEXT.md
@.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement graceful stop with timeout and force kill fallback</name>
  <files>internal/lifecycle/stopper.go</files>
  <action>
Create internal/lifecycle/stopper.go implementing graceful stop with 5-second timeout and force kill fallback.

Use taskkill command (Windows) - DO NOT use syscall.SIGTERM (does not work on Windows per research pitfall).

```go
package lifecycle

import (
    "context"
    "fmt"
    "os"
    "os/exec"
    "syscall"
    "time"
)

// StopNanobot gracefully stops nanobot process, force-killing after timeout.
// timeout is the maximum time to wait for graceful shutdown before force kill.
// Returns error if stop fails completely.
func StopNanobot(ctx context.Context, pid int32, timeout time.Duration) error {
    if pid <= 0 {
        return nil // Nothing to stop
    }

    // Create timeout context for the entire stop operation
    stopCtx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()

    // Step 1: Try graceful termination (taskkill without /f)
    // This sends WM_CLOSE message to the process
    gracefulCmd := exec.CommandContext(stopCtx, "taskkill", "/PID", fmt.Sprintf("%d", pid))
    gracefulCmd.SysProcAttr = &syscall.SysProcAttr{
        HideWindow:    true,
        CreationFlags: syscall.CREATE_NO_WINDOW,
    }

    err := gracefulCmd.Run()
    if err == nil {
        // Graceful termination succeeded, wait for process to exit
        if waitForProcessExit(stopCtx, pid, 2*time.Second) {
            return nil
        }
    }

    // Step 2: Force kill (taskkill /f)
    forceCmd := exec.CommandContext(stopCtx, "taskkill", "/F", "/PID", fmt.Sprintf("%d", pid))
    forceCmd.SysProcAttr = &syscall.SysProcAttr{
        HideWindow:    true,
        CreationFlags: syscall.CREATE_NO_WINDOW,
    }

    if err := forceCmd.Run(); err != nil {
        return fmt.Errorf("force kill failed: %w", err)
    }

    // Verify process is gone
    if !waitForProcessExit(stopCtx, pid, 1*time.Second) {
        return fmt.Errorf("process %d did not terminate after force kill", pid)
    }

    return nil
}

// waitForProcessExit polls until the process exits or context is done
func waitForProcessExit(ctx context.Context, pid int32, pollInterval time.Duration) bool {
    ticker := time.NewTicker(pollInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return false
        case <-ticker.C:
            // Check if process still exists
            process, err := os.FindProcess(int(pid))
            if err != nil {
                return true // Process doesn't exist
            }
            // On Windows, FindProcess always succeeds, so we try to signal
            err = process.Signal(syscall.Signal(0))
            if err != nil {
                return true // Process has exited
            }
        }
    }
}
```

This implements IMPL-02: "Stop nanobot gracefully with 5s timeout, force kill if needed".

Critical: Use SysProcAttr with HideWindow and CREATE_NO_WINDOW to prevent console flashing.
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Check that stopper.go exports StopNanobot function with correct signature.
Verify taskkill is used (not SIGTERM).
  </verify>
  <done>
internal/lifecycle/stopper.go exists and compiles.
StopNanobot attempts graceful taskkill first, then force taskkill.
waitForProcessExit helper function exists.
SysProcAttr with CREATE_NO_WINDOW is used for hidden execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement hidden background start with port verification</name>
  <files>internal/lifecycle/starter.go</files>
  <action>
Create internal/lifecycle/starter.go implementing hidden background process startup with port verification.

```go
package lifecycle

import (
    "context"
    "fmt"
    "net"
    "os/exec"
    "syscall"
    "time"
)

// StartNanobot starts nanobot gateway in the background with hidden window.
// Returns error if startup fails or port is not listening within timeout.
func StartNanobot(ctx context.Context, port uint32, startupTimeout time.Duration) error {
    // Start nanobot gateway as background process
    cmd := exec.Command("nanobot", "gateway")
    cmd.SysProcAttr = &syscall.SysProcAttr{
        HideWindow:    true,
        CreationFlags: syscall.CREATE_NO_WINDOW | syscall.CREATE_NEW_PROCESS_GROUP,
    }

    // Detach from parent - don't wait for completion
    if err := cmd.Start(); err != nil {
        return fmt.Errorf("failed to start nanobot: %w", err)
    }

    // Release the process so it continues independently
    if err := cmd.Process.Release(); err != nil {
        return fmt.Errorf("failed to detach nanobot process: %w", err)
    }

    // Verify startup by checking port becomes available
    if err := waitForPortListening(ctx, port, startupTimeout); err != nil {
        return fmt.Errorf("nanobot startup verification failed: %w", err)
    }

    return nil
}

// waitForPortListening polls until the port is listening or timeout
func waitForPortListening(ctx context.Context, port uint32, timeout time.Duration) error {
    deadline := time.Now().Add(timeout)
    address := fmt.Sprintf("127.0.0.1:%d", port)

    for time.Now().Before(deadline) {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            // Try to connect to verify port is listening
            conn, err := net.DialTimeout("tcp", address, 1*time.Second)
            if err == nil {
                conn.Close()
                return nil // Port is listening
            }
            time.Sleep(500 * time.Millisecond)
        }
    }

    return fmt.Errorf("port %d not listening after %v", port, timeout)
}
```

This implements:
- IMPL-03: "Start nanobot gateway after update with hidden window"
- IMPL-04: "Verify startup by port listening check"

Critical patterns from research:
- Use cmd.Start() + Release() for detached process (NOT cmd.Run())
- Use CREATE_NEW_PROCESS_GROUP flag for proper detachment
- Poll port with net.DialTimeout to verify startup
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Check that starter.go exports StartNanobot function.
Verify CREATE_NO_WINDOW and CREATE_NEW_PROCESS_GROUP flags are used.
Verify cmd.Process.Release() is called for detachment.
  </verify>
  <done>
internal/lifecycle/starter.go exists and compiles.
StartNanobot starts "nanobot gateway" with hidden window.
Process is detached using Release().
waitForPortListening verifies port becomes available.
CREATE_NO_WINDOW and CREATE_NEW_PROCESS_GROUP flags are set.
  </done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must compile without errors
2. Verify internal/lifecycle/stopper.go exists with StopNanobot function
3. Verify internal/lifecycle/starter.go exists with StartNanobot function
4. Verify both files use SysProcAttr with CREATE_NO_WINDOW
5. Verify stopper uses taskkill (not SIGTERM)
6. Verify starter uses cmd.Start() + Release() (not cmd.Run())
</verification>

<success_criteria>
- StopNanobot attempts graceful taskkill, then force taskkill after timeout
- StopNanobot uses waitForProcessExit to verify process termination
- StartNanobot starts "nanobot gateway" with CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP
- StartNanobot releases process for independent execution
- waitForPortListening verifies port is listening within timeout
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-02-SUMMARY.md`
</output>
