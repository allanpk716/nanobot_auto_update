---
phase: 01.1-nanobot-lifecycle-management-stop-before-update-start-after-update
plan: 03
type: execute
wave: 2
depends_on:
  - 01.1-01
  - 01.1-02
files_modified:
  - internal/lifecycle/manager.go
  - internal/config/config.go
autonomous: true
requirements:
  - IMPL-01
  - IMPL-02
  - IMPL-03
  - IMPL-04
user_setup: []

must_haves:
  truths:
    - "Lifecycle manager orchestrates stop-before-update-start-after-update sequence"
    - "Stop failure cancels the update (returns error)"
    - "Start failure logs warning but does not fail the update"
    - "Nanobot configuration is properly loaded and validated"
  artifacts:
    - path: "internal/lifecycle/manager.go"
      provides: "Lifecycle orchestration with stop/start coordination"
      exports: ["Manager", "NewManager", "StopForUpdate", "StartAfterUpdate"]
    - path: "internal/config/config.go"
      provides: "Config loading with nanobot section integration"
      contains: "Nanobot.Validate()"
  key_links:
    - from: "internal/lifecycle/manager.go"
      to: "internal/lifecycle/detector.go"
      via: "IsNanobotRunning"
      pattern: "IsNanobotRunning"
    - from: "internal/lifecycle/manager.go"
      to: "internal/lifecycle/stopper.go"
      via: "StopNanobot"
      pattern: "StopNanobot"
    - from: "internal/lifecycle/manager.go"
      to: "internal/lifecycle/starter.go"
      via: "StartNanobot"
      pattern: "StartNanobot"
    - from: "internal/lifecycle/manager.go"
      to: "internal/config/config.go"
      via: "NanobotConfig"
      pattern: "NanobotConfig"
---

<objective>
Create lifecycle manager that orchestrates stop-start sequence and integrate nanobot config into config loading.

Purpose: Provide a unified Manager that coordinates stopping nanobot before updates and starting it after, with proper error handling per user decisions.
Output: manager.go with Manager struct, config validation integration.
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/allan716/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-CONTEXT.md
@.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lifecycle manager orchestrating stop/start</name>
  <files>internal/lifecycle/manager.go</files>
  <action>
Create internal/lifecycle/manager.go with the Manager struct that coordinates stop-start sequence.

```go
package lifecycle

import (
    "context"
    "fmt"
    "time"
)

// Manager orchestrates nanobot lifecycle (stop before update, start after update)
type Manager struct {
    port           uint32
    startupTimeout time.Duration
    stopTimeout    time.Duration
}

// Config holds lifecycle manager configuration
type Config struct {
    Port           uint32        `yaml:"port"`
    StartupTimeout time.Duration `yaml:"startup_timeout"`
}

// NewManager creates a new lifecycle manager
func NewManager(cfg Config) *Manager {
    return &Manager{
        port:           cfg.Port,
        startupTimeout: cfg.StartupTimeout,
        stopTimeout:    5 * time.Second, // Locked decision: 5 second timeout
    }
}

// StopForUpdate stops nanobot before update.
// Returns error if stop fails - this should cancel the update.
func (m *Manager) StopForUpdate(ctx context.Context) error {
    running, pid, err := IsNanobotRunning(m.port)
    if err != nil {
        return fmt.Errorf("failed to detect nanobot: %w", err)
    }

    if !running {
        // Not running, nothing to stop
        return nil
    }

    if err := StopNanobot(ctx, pid, m.stopTimeout); err != nil {
        return fmt.Errorf("failed to stop nanobot (PID %d): %w", pid, err)
    }

    return nil
}

// StartAfterUpdate starts nanobot after update.
// Returns error if start fails, but update is still considered successful.
// Caller should log the error but not fail the update.
func (m *Manager) StartAfterUpdate(ctx context.Context) error {
    // Always start regardless of previous state (locked decision)
    if err := StartNanobot(ctx, m.port, m.startupTimeout); err != nil {
        return fmt.Errorf("failed to start nanobot (user can start manually): %w", err)
    }
    return nil
}
```

This implements the locked decisions from CONTEXT.md:
- Stop failure = cancel update (returns error)
- Start failure = log warning (returns error but caller should not fail update)
- Always start after update regardless of previous state
- Stop timeout is fixed at 5 seconds
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Check that manager.go exports Manager, NewManager, StopForUpdate, StartAfterUpdate.
Verify StopForUpdate calls IsNanobotRunning and StopNanobot.
Verify StartAfterUpdate calls StartNanobot.
  </verify>
  <done>
internal/lifecycle/manager.go exists and compiles.
Manager struct with port, startupTimeout, stopTimeout fields.
NewManager creates Manager from Config.
StopForUpdate returns error on failure (cancels update).
StartAfterUpdate returns error on failure (logs warning only).
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate nanobot config validation</name>
  <files>internal/config/config.go</files>
  <action>
Update internal/config/config.go to add validation for NanobotConfig.

Add a Validate method to NanobotConfig:

```go
func (c *NanobotConfig) Validate() error {
    if c.Port == 0 {
        return errors.New("nanobot.port cannot be 0")
    }
    if c.Port > 65535 {
        return errors.New("nanobot.port must be <= 65535")
    }
    if c.StartupTimeout < 5*time.Second {
        return errors.New("nanobot.startup_timeout must be at least 5 seconds")
    }
    return nil
}
```

Update the main config Load function (or equivalent) to call Nanobot.Validate() as part of config validation.

Ensure the config loading flow:
1. Load config from file
2. Apply defaults for missing fields
3. Validate all sections including Nanobot

If the project uses a validation pattern in the existing config, follow that pattern for consistency.
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Check that NanobotConfig.Validate() method exists.
Verify validation is called during config loading.
  </verify>
  <done>
NanobotConfig.Validate() method exists.
Validation checks Port > 0 and <= 65535.
Validation checks StartupTimeout >= 5 seconds.
Config loading calls Nanobot.Validate().
  </done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must compile without errors
2. Verify internal/lifecycle/manager.go exists with Manager struct
3. Verify StopForUpdate returns error on stop failure
4. Verify StartAfterUpdate returns error but documents update still successful
5. Verify NanobotConfig.Validate() exists and is called during config loading
6. Run `go test ./...` if tests exist
</verification>

<success_criteria>
- Manager struct coordinates IsNanobotRunning, StopNanobot, StartNanobot
- StopForUpdate cancels update on failure (returns error)
- StartAfterUpdate logs warning on failure (returns error for caller to log)
- stopTimeout is fixed at 5 seconds in NewManager
- NanobotConfig.Validate() validates port and startup_timeout
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-03-SUMMARY.md`
</output>
