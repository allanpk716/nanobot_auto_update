---
phase: 01.1-nanobot-lifecycle-management-stop-before-update-start-after-update
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/config/config.go
  - internal/lifecycle/detector.go
autonomous: true
requirements:
  - IMPL-01
user_setup: []

must_haves:
  truths:
    - "Nanobot running status can be detected by checking port 18790"
    - "Process detection returns PID if nanobot is running"
    - "Nanobot configuration is loaded from config.yaml"
  artifacts:
    - path: "internal/lifecycle/detector.go"
      provides: "Port-based process detection using gopsutil"
      exports: ["FindPIDByPort", "IsNanobotRunning"]
    - path: "internal/config/config.go"
      provides: "NanobotConfig struct with Port and StartupTimeout"
      contains: "type NanobotConfig struct"
  key_links:
    - from: "internal/lifecycle/detector.go"
      to: "github.com/shirou/gopsutil/v3/net"
      via: "net.Connections()"
      pattern: "net\\.Connections\\(\"tcp\"\\)"
---

<objective>
Add nanobot lifecycle configuration and implement port-based process detection.

Purpose: Enable detection of whether nanobot is running by checking if port 18790 is listening, and provide configuration for lifecycle management.
Output: NanobotConfig struct in config, detector.go with FindPIDByPort and IsNanobotRunning functions.
</objective>

<execution_context>
@C:/Users/allan716/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/allan716/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-CONTEXT.md
@.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NanobotConfig to configuration</name>
  <files>internal/config/config.go</files>
  <action>
Add NanobotConfig struct to internal/config/config.go with the following fields:

```go
type NanobotConfig struct {
    Port           uint32        `yaml:"port" mapstructure:"port"`
    StartupTimeout time.Duration `yaml:"startup_timeout" mapstructure:"startup_timeout"`
}
```

Add `Nanobot NanobotConfig `yaml:"nanobot"`` field to the main Config struct.

Set default values in the defaults() function:
- Port: 18790
- StartupTimeout: 30 * time.Second

Add validation in a new Validate() method on NanobotConfig:
- Port must be > 0 and <= 65535
- StartupTimeout must be at least 5 seconds

Update config.yaml with the new section:
```yaml
nanobot:
  port: 18790
  startup_timeout: 30s
```

This implements the locked decision from CONTEXT.md: "nanobot configuration in independent section with port and startup timeout".
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Check that `internal/config/config.go` contains `type NanobotConfig struct` and `Nanobot NanobotConfig` field.
  </verify>
  <done>
NanobotConfig struct exists with Port and StartupTimeout fields.
Default values are 18790 and 30s.
Config struct includes Nanobot field.
config.yaml includes nanobot section.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement port-based process detection</name>
  <files>internal/lifecycle/detector.go</files>
  <action>
Create internal/lifecycle/detector.go with port-based process detection using gopsutil.

First, add the dependency:
```bash
go get github.com/shirou/gopsutil/v3/net
```

Implement the following functions:

```go
package lifecycle

import (
    "fmt"
    "github.com/shirou/gopsutil/v3/net"
)

// FindPIDByPort returns the PID of the process listening on the specified port.
// Returns 0 if no process is listening on that port.
func FindPIDByPort(port uint32) (int32, error) {
    connections, err := net.Connections("tcp")
    if err != nil {
        return 0, fmt.Errorf("failed to get network connections: %w", err)
    }

    for _, conn := range connections {
        // Check if connection is listening on the specified port
        if conn.Status == "LISTEN" && conn.Laddr.Port == port {
            return conn.Pid, nil
        }
    }

    return 0, nil // No process found, not an error
}

// IsNanobotRunning checks if nanobot is running on the specified port.
// Returns (isRunning, pid, error).
func IsNanobotRunning(port uint32) (bool, int32, error) {
    pid, err := FindPIDByPort(port)
    if err != nil {
        return false, 0, err
    }
    return pid > 0, pid, nil
}
```

This implements IMPL-01: "Detect nanobot running by port 18790".
Uses gopsutil/net per research recommendation to avoid fragile netstat parsing.
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Run `go test ./internal/lifecycle/...` if tests exist.
Check that detector.go exports FindPIDByPort and IsNanobotRunning functions.
  </verify>
  <done>
internal/lifecycle/detector.go exists and compiles.
FindPIDByPort returns PID of process on specified port.
IsNanobotRunning returns (bool, int32, error) indicating running status.
  </done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must compile without errors
2. Run `go mod tidy` to ensure dependencies are clean
3. Verify internal/config/config.go has NanobotConfig with Port and StartupTimeout
4. Verify internal/lifecycle/detector.go has FindPIDByPort and IsNanobotRunning
5. Verify config.yaml has nanobot section with port and startup_timeout
</verification>

<success_criteria>
- NanobotConfig struct exists in config with Port (uint32) and StartupTimeout (time.Duration)
- Default port is 18790, default startup timeout is 30s
- detector.go implements FindPIDByPort using gopsutil/net
- IsNanobotRunning wraps FindPIDByPort to return (bool, int32, error)
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-nanobot-lifecycle-management-stop-before-update-start-after-update/01.1-01-SUMMARY.md`
</output>
